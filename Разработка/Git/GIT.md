# Git

## Система контроля версий

Система контроля версий, или VCS — это программное обеспечение, которое помогает отслеживать изменения в программах, текстовых файлах, больших документах, веб-сайтах и так далее. 

Одно изменение или группу изменений в VCS называют ревизией или версией. Каждая такая ревизия содержит информацию о том, что изменилось, кто внёс изменения, когда это было и иногда комментарии к изменению.

Основные функции системы контроля версий:

- хранит историю изменений в виде отдельных ревизий;
- позволяет манипулировать историей: например, менять порядок ревизий, полностью удалять версии, возвращаться назад в истории;
- помогает анализировать изменения: например, кто и когда вносит изменения, кто чаще всего вносит изменения в определённый файл и так далее.

Одна из ключевых особенностей современных систем контроля версий — поддержка параллельной работы нескольких пользователей, в том числе над одним файлом. 

Git — это программа, которая в том числе может работать из командной строки. Любой графический интерфейс для Git всего лишь преобразует клики пользователя в вызовы программы.

![Untitled](../../Вложения/GIT/Untitled.png)

Работу с Git через консоль можно осуществлять в программе Git Bash.

## Настройка GIT

Git позволяет сохранять изменения локально и при необходимости возвращаться к предыдущим версиям проекта. Также можно создать удалённую копию на хостинг-платформе, которая работает с Git, и поделиться результатом с другими.

Для того, чтобы начать работать с Git, необходимо создать файл .gitconfig в домашней директории:

```bash
$ git config --global user.name "Vorovatov Timofey"
$ git config --global user.email timodrul@gmail.com
```

![Untitled](../../Вложения/GIT/Untitled%201.png)

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием:

```bash
$ git init directory
```

![Untitled](../../Вложения/GIT/Untitled%202.png)

Чтобы папка перестала быть репозиторием, можно использовать команду:

```bash
# rm - remove
# -r - рекурсивно
# -f - force (без проверок вроде "точно ли вы хотите..")
$ cd directory
$ rm -rf .git
```

Чтобы посмотреть состояние репозитория на данный момент и текущую ветку, используется команда:

```bash
$ git status
/ On branch master
/ No commits yet
/ nothing to commit (create/copy files and use "git add" to track)

```

После того, как нужные файлы перенесены в папку-репозиторий или созданы в ней, их нужно начать отслеживать. Делается это командой:

```bash
$ git add file
# или
$ git add --all # чтобы отслеживать все файлы в папке
```

Сам git add не сохраняет файлы в репозитории, а только запоминает их текущее состояние. Если после этого изменить файл, а потом снова прописать git add, состояние обновится.

Чтобы сохранить внесенные изменения, нужно прописать команду:

```bash
$ git commit -m "комментарий"
```

Чтобы посмотреть историю коммитов, используют команду:

```bash
$ git log
```

![Untitled](../../Вложения/GIT/Untitled%203.png)

Информация в git log содержит:

- Строку из цифр и латинских букв после слова commit — это хеш коммита;
- Author — имя автора и его электронная почта;
- Date — дату и время создания коммита;
- Сообщение коммита.

Можно также вывести сокращенный лог командой git log - - oneline

## Интеграция с GitHub

Чтобы соединить удаленный репозиторий с локальным, его нужно сперва создать:

![Untitled](../../Вложения/GIT/Untitled%204.png)

![Untitled](../../Вложения/GIT/Untitled%205.png)

Затем соединение нужно настроить при помощи SSH-ключей. Это один из наиболее распространённых сетевых протоколов (от англ. Secure Shell Protocol). Он обеспечивает безопасный обмен данными в сети. 

С помощью этого протокола можно получать данные с удалённого компьютера или отправлять их на него. Трафик шифруется, поэтому протокол безопасен.

SSH использует пару ключей для обеспечения безопасности — публичный и приватный:

- Приватный ключ (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- Публичный ключ (англ. public key) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.

### Генерация SSH-ключа:

Используем программу ssh-keygen:

```bash
$ ssh-keygen -t ed25519 -C "timodrul@gmail.com"
```

![Untitled](../../Вложения/GIT/Untitled%206.png)

Выбор директории и создание пароля можно пропустить.

Посмотреть созданные ключи можно так:

![Untitled](../../Вложения/GIT/Untitled%207.png)

Далее содержимое публичного ключа (с расширением .pub) нужно скопировать в буфер обмена:

![Untitled](../../Вложения/GIT/Untitled%208.png)

Далее в настройках аккаунта на GitHub нужно найти вкладку SSH and GPG keys и нажать New SSH key.

![Untitled](../../Вложения/GIT/Untitled%209.png)

![Untitled](../../Вложения/GIT/Untitled%2010.png)

В отрывшееся поле нужно вставить содержимое файла с публичным ключом. 

После этого можно осуществить коннект командой:

```bash
$ ssh -T git@github.com 
```

### Привязка локального репозитория к удаленному

Сперва нужно скопировать URL со страницы созданного репозитория, выбрав SSH:

![Untitled](../../Вложения/GIT/Untitled%2011.png)

После этого в командной строке необходимо прописать команду:

```bash
$ git remote add name url
```

![Untitled](../../Вложения/GIT/Untitled%2012.png)

Проверить, что репозитории успешно связаны, можно командой:

```bash
$ git remote -v
```

![Untitled](../../Вложения/GIT/Untitled%2013.png)

Чтобы удалить привязку к удаленному репозиторию, можно воспользоваться командой:

```bash
$ git remote rm name   
```

### Отправка изменений на удаленный репозиторий

Чтобы отправить закоммиченные изменения в удаленный репозиторий, нужно прописать команду:

```bash
$ git push -u name branch
```

![Untitled](../../Вложения/GIT/Untitled%2014.png)

После этого, измененные файлы появятся в удаленном репозитории:

![Untitled](../../Вложения/GIT/Untitled%2015.png)

В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто git push

## Навигация по коммитам

### Хеш

У каждого коммита есть свой хеш, по которому его можно однозначно идентифицировать.

Хеш обладает следующими свойствами:

- Если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- Если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Все хеши и таблицу хеш `→` информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.

### HEAD

В папке .git есть файл HEAD, который хранит указатель на коммит (хеш), который был сделан последним.

![Untitled](../../Вложения/GIT/Untitled%2016.png)

При работе с Git указатель HEAD используется довольно часто. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

### Статусы

- untracked - новые файлы в Git-репозитории, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
- staged - после выполнения команды git add файл попадает в staging area, то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
- tracked - противоположность untracked. Понятие довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
- modified - означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

![Untitled](../../Вложения/GIT/Untitled%2017.png)

### Редактирование коммита

Вместо того, чтобы сделать новый коммит, можно отредактировать старый: поменять комментарий, добавить новые файлы, изменить уже добавленные файлы и т.д.

Делается этого при помощи флага - - amend:

```bash
$ git commit --amend -m "исправленный комментарий"
```

```bash
$ git add file_2
$ git commit --amend --no-edit # без изменения комментария
```

### Исправление ошибок

Чтобы убрать файл из состояния staged, нужно выполнить команду:

```bash
$ git restore --staged file
```

![Untitled](../../Вложения/GIT/Untitled%2018.png)

Чтобы убрать все файлы из текущей папки из staged, можно использовать:

```bash
$ git restore --staged .
```

Чтобы откатить незакоммиченные и незафиксированные изменения в файле, который был изменен, можно использовать команду:

```bash
$ git restore file
```

![Untitled](../../Вложения/GIT/Untitled%2019.png)

Файл вернется к состоянию, в котором находился на момент последнего git commit или git add

Чтобы откатить какой-то коммит и вернуться к более ранней версии, используется команда:

```bash
$ git reset --hard commit_hash
```

![Untitled](../../Вложения/GIT/Untitled%2020.png)

Будьте осторожны с командой git reset --hard! При удалении коммитов можно потерять что-то нужное.

Чтобы по такой же логике откатить один файл к состоянию, в котором он был на момент последнего коммита, можно использовать команду:

```bash
$ git checkout HEAD -- file
```

![Untitled](../../Вложения/GIT/Untitled%2021.png)

![Untitled](../../Вложения/GIT/Untitled%2022.png)

Чтобы посмотреть, какие именно изменения были внесены в modified файлы, можно использовать команду:

```bash
$ git diff
```

![Untitled](../../Вложения/GIT/Untitled%2023.png)

- красный цвет строки значит, что эта строка была удалена;
- зелёный цвет строки значит, что она была добавлена.

Аналогично со staged файлами:

```bash
$ git diff --staged
```

Можно также сравнить два отдельных коммита:

```bash
$ git diff hash_1 hash_2
```

![Untitled](../../Вложения/GIT/Untitled%2024.png)

### .gitignore

Чтобы Git игнорировал определенные файлы и не пытался добавить их в репозиторий, нужно создать файл .gitignore и записать в него названия игнорируемых файлов. 

В простейшем случае в .gitignore указывают все файлы, которые нужно игнорировать (по одному имени на строку). Но часто удобнее использовать шаблоны. Шаблон, или правило, — это способ указать сразу на несколько файлов с однотипными названиями.

Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.

Правила шаблонов:
1. Символ звёздочки () соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.

```bash
# игнорировать все файлы, которые заканчиваются на .jpeg
.jpeg

# игнорировать все файлы "tmp" во всех подпапках папки docs
docs//tmp 

# парная звездочка обозначает любое количество таких подпапок:
docs//tmp 
```

1. Вопросительный знак (?) - один любой символ.
2. Квадратные скобки ([…]) - один из перечисленных символов или из диапазона (как regex)
3. Слеш (/) - указывает на каталоги, которые нужно исключить
4. Восклицательный знак (!) - инверсия любого из правил

Например:

```bash
# игнорировать все файлы


# кроме .tex и .pdf
!.tex
!.pdf 
```

## Командная работа в Git

### Клонирование

Для того, чтобы работать с каким-то проектом, его нужно сначала скопировать на локальный компьютер.

Для этого нужно скопировать ссылку на удаленный репозиторий, в котором лежит этот проект:

![Untitled](../../Вложения/GIT/Untitled%2025.png)

А затем нужно передать эту ссылку команде git clone, Находясь в нужной папке:

```bash
$ git clone url
```

Команда git clone автоматически связывает локальный и удалённый репозиторий. То есть если в GitHub-репозитории что-то поменяется (например, добавятся коммиты), вам не нужно будет заново клонировать его. Достаточно будет выполнить команду, которая обновит вашу копию.

### Создание Fork-а

Альтернативный вариант - создать копию репозитория в своем аккаунте GitHub, работать с ней, а уже затем отправить запрос на включение изменений в оригинальный проект.

Это нужно, если у вас нет прав на внесение изменений в проект, в который вы хотите добавить какую-то новую функциональность. 

Создать форк можно прямо в GitHub:

![Untitled](../../Вложения/GIT/Untitled%2026.png)

После того, как копия репозитория создана, ее можно клонировать на локальный компьютер и работать так же, как в первом примере.

### Ветки

Ветка — это изолированный поток разработки проекта. В таком потоке можно проверять разные идеи, тестировать новую функциональность и так далее.

Ветки позволяют экспериментировать с проектом в Git, но при этом сохранять репозиторий в стабильном состоянии. Каждый член команды может работать в своей ветке и не мешать другим: коммиты, которые он сделает, не будут видны из других веток. А когда работа будет доделана, ветки можно соединить.

Основная, стабильная версия проекта хранится в главной ветке main или master. Она появляется автоматически при создании репозитория. Часто все новые ветки в репозитории отходят от main, хотя это не является правилом.<br>
Чтобы посмотреть, какие ветки есть в проекте, используется команда:

```bash
$ git branch
```

![Untitled](../../Вложения/GIT/Untitled%2027.png)

Звёздочкой () отмечено, в какой ветке вы находитесь в текущий момент.<br>
Чтобы создать новую ветку, используют команду:

```bash
$ git branch name
```

Чтобы переключиться на другую ветку, используют команду:

```bash
$ git checkout branch_name
```

Можно также использовать git checkout -b branch_name, чтобы создать новую ветку и сразу на нее переключиться.

![Untitled](../../Вложения/GIT/Untitled%2028.png)

Посмотреть отличия между ветками можно при помощи команды:

```bash
$ git diff branch_1 branch_2
```

![Untitled](../../Вложения/GIT/Untitled%2029.png)

Сравнение можно также производить по хешам коммитов.

Чтобы не писать хеши каждый раз, можно использовать суффиксы навигации:

```bash
$ git diff HEAD~ HEAD # ~ обозначает предпоследний коммит перед указанным
$ git diff branch1~2 branch2 
# ~2 обозначает коммит, который был на 2 раньше, чем указанный
```

После ~ можно указать любое число. Если прописать ~ после названия ветки, отсчет будет вестись с последнего коммита в ней. 

Чтобы объединить две ветки в одну, нужно перейти в ветку, в которую должны добавиться изменения, и использовать команду:

```bash
$ git merge branch_name
```

![Коммиты из второй ветки, таким образом, последовательно применяются к первой.](../../Вложения/GIT/Untitled%2030.png)

Коммиты из второй ветки, таким образом, последовательно применяются к первой.

Чтобы удалить ветку (например, после объединения), можно использовать команду:

```bash
$ git branch -D branch_name
```

Удаление локальной ветки через Git не удаляет ветку на GitHub.

Чтобы запушить новую ветку на GitHub, используется команда:

```bash
$ git push -u name branch
```

При работе над групповым проектом нельзя просто сливать свою ветку с основной на GitHub. Сперва нужно пройти процедуру pull request.

### Про pull request

У каждого пул-реквеста есть:

- Название — краткое описание предлагаемых изменений.
- Описание — развёрнутое описание изменений.
- Исходная ветка — та, в которой вы работали.
- Целевая ветка — основная ветка проекта, в которую вы хотите внести изменения.

У каждого пул-реквеста может быть два исхода:

- merge — предлагаемые изменения приняты; код вливается в целевую ветку; пул-реквест закрывается.
- close — пул-реквест закрывается без слияния изменений.

После того, как ветка запушена на GitHub, можно пройти во вкладку Pull requests: 

![Untitled](../../Вложения/GIT/Untitled%2031.png)

Нужно выбрать из какой ветки в какую будет производиться слияние:

![Untitled](../../Вложения/GIT/Untitled%2032.png)

И создать сам пул-реквест:

![Untitled](../../Вложения/GIT/Untitled%2033.png)

После этого другие члены команды могут обсудить предлагаемые изменения и провести код-ревью:

![Untitled](../../Вложения/GIT/Untitled%2034.png)

Когда все правки внесены, merge может быть наконец произведен:

![Untitled](../../Вложения/GIT/Untitled%2035.png)

Чтобы скачать изменения из удалённого репозитория, следует перейти в нужную ветку на локальном устройстве и выполнить команду:

```bash
$ git pull
```

git pull имеет смысл применять перед созданием пул-реквеста, чтобы подтянуть все изменения, которые успела претерпеть основная ветка за время работы.

Например, так может выглядеть стандартный алгоритм подготовки к созданию пул-реквеста:

```bash
$ git checkout main # перешли в main
$ git pull # подтянули новые изменения в main
$ git checkout my-branch # вернулись в рабочую ветку my-branch
$ git merge main # влили main в новую ветку my-branch
$ git push -u origin my-branch # отправили ветку my-branch в удалённый репозиторий
```

### Feature branch workflow

Основная идея модели feature branch workflow в том, что работа над любой новой функциональностью или исправлением ведётся в отдельной ветке.<br>
Такой подход позволяет разработчикам трудиться над новыми фичами независимо друг от друга и не затрагивать основную ветку кода в процессе. Так как каждый работает над своей веткой самостоятельно, не возникает проблемы «расходящейся» общей ветки, которую мы описали в прошлом уроке.

![Untitled](../../Вложения/GIT/Untitled%2036.png)

При таком подходе все коммиты в ветке main — это коммиты слияния (feature-ветки вливаются в main).

Если аккуратно следовать подходу feature branch workflow, то:

- Не будет проблемы «расхождения» веток, ведь новые изменения попадают в main через git merge, а не через git push. Команду merge «разошедшиеся» ветки не смущают, ведь для них она и придумана.
- В ветке main всегда рабочая версия проекта. Все «полуфабрикаты» и недоделанные функциональности находятся в feature ветках, пока не будут готовы попасть в main.

В большинстве команд новые функциональности и исправления попадают в main через запрос на слияние. Его так и называют — пул-реквест или мёрж-реквест.

После одобрения пул-реквеста его автор (или один из участников проекта) может нажать кнопку Merge. Тогда GitHub (или GitLab/BitBucket) вольёт feature -ветку в main. В зависимости от настроек система также предложит удалить саму feature -ветку, потому что она уже не нужна: все изменения есть в main после слияния.

## Конфликты

Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. Конфликт — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. При этом результаты таких модификаций оказались несовместимы и разобраться в том, какой из вариантов правильный, может только человек.

![Untitled](../../Вложения/GIT/Untitled%2037.png)

Конфликт предупреждает, что вам нужно ещё раз посмотреть текущее состояние ветки master, убедиться, что ваши изменения всё ещё верные, и самостоятельно соединить их.

### Fast-forward

Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая. Это утверждение можно сформулировать иначе:

- при слиянии этих двух веток никак не возможен конфликт;
- истории этих двух веток не «разошлись»;
- одна ветка является продолжением другой.

![Untitled](../../Вложения/GIT/Untitled%2038.png)

![Untitled](../../Вложения/GIT/Untitled%2039.png)

Fast-forward режим слияния можно отключить, используя флаг:

```bash
$ git merge --no-edit --no-ff branch
```

Тогда итоговая версия будет выглядеть так:

![Untitled](../../Вложения/GIT/Untitled%2040.png)

### Non-fast-forward

Если истории двух веток «разошлись» и их коммиты уже нельзя выстроить в одну линию, то такие ветки находятся в состоянии Non-fast-forward.

![Untitled](../../Вложения/GIT/Untitled%2041.png)

Когда Git проверяет ветки на состояние fast-forward, он не «заглядывает» в файлы и не пытается угадать, будет ли конфликт на самом деле. Для Git важно только, что конфликт теоретически возможен (или, наоборот, никак не возможен).

При слиянии None-fast-forward веток Git создаёт коммит слияния. Если конфликты всё-таки есть, Git сначала попытается разрешить их автоматически. Если не получится, Git предложит вам разрешить их вручную. 

![Untitled](../../Вложения/GIT/Untitled%2042.png)

### Git push и fast-forward

Аналогичные отношения могут возникать между состоянием удаленного репозитория и тем, что в него пытаются поместить при помощи git push:

![Untitled](../../Вложения/GIT/Untitled%2043.png)

![Untitled](../../Вложения/GIT/Untitled%2044.png)

Если локальная и удаленная ветки находятся в состоянии None-fast-forward, git предложит выполнить команду git pull, прежде чем сливать их. 

В качестве альтернативы можно использовать команду rebase, которая меняет коммит, от которого отделилась ветка:

![Untitled](../../Вложения/GIT/Untitled%2045.png)

Также можно использовать команду git push --force, которая просто удаляет все коммиты, которые не дают объединить ветки:

```bash
$ git push --force 
```

 В очень редких случаях это уместная команда. Например, если кто-то нечаянно «сломал» ветку main@origin, можно найти копию репозитория, в которой ветка main не «сломана», и использовать git push --force для восстановления ветки в origin.

### Разрешение конфликта вручную

Пусть есть проект с тремя ветками: master, side_1 и side_2. В каждой из веток содержится своя версия файла lore.txt.

![Untitled](../../Вложения/GIT/Untitled%2046.png)

Одну из веток можно объединить с веткой master, но если потом попытаться добавить туда же вторую, образуется конфликт:

![Untitled](../../Вложения/GIT/Untitled%2047.png)

Теперь, если открыть файл, который не удалось смерджить, можно увидеть размеченные git-ом отличия:

![Untitled](../../Вложения/GIT/Untitled%2048.png)

В этом файле можно руками оставить только то, что нужно, а все остальное - включая маркеры конфликтов - удалить.

После этого нужно просто еще раз прописать git add и git commit, чтобы зафиксировать изменения.

![Untitled](../../Вложения/GIT/Untitled%2049.png)

Решать такие конфликты в случае с кодом можно в Visual Studio Code. Там можно открыть файл, в котором возник конфликт и руками поправить код, либо выбрать одну из предлагаемых опций:

- Accept Current Change — разрешить конфликт через изменения, которые были раньше.
- Accept Incoming Change — разрешить конфликт через изменения, которые внесли вы.
- Accept Both Changes — добавить оба изменения одно за другим.

Это удобно, если изменений немного. На случай, если таких изменений больше, у VS Code есть более мощный графический интерфейс для конфликтов. Чтобы его открыть, нажмите на кнопку Resolve in Merge Editor в правом нижнем углу экрана.