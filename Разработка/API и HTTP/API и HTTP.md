# API и HTTP

## Понятие HTTP

**HTTP** (*HyperText Transfer Protocol*) - это протокол для обмена сообщениями в интернете.

Протокол HTTP предполагает использование **клиент-серверной структуры передачи данных**:

- Клиентское приложение формирует **запрос** и отправляет его на сервер.
- Серверное программное обеспечение обрабатывает данный запрос, формирует **ответ** и передаёт его обратно клиенту.
- После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.

**Структура запроса:**

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled.png)

**Структура ответа:**

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%201.png)

**Стартовая строка** состоит из:

1. HTTP метода
2. Эндпоинта, в который пришел запрос
3. Версии протокола

**Строка статуса** состоит из:

1. HTTP метода
2. Версии протокола 
3. Кода ответа

### HTTP методы:

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%202.png)

- **GET** запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
- **HEAD** запрашивает ресурс так же, как и метод **GET**, но без тела ответа.
- **POST** используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
- **PUT** заменяет все текущие представления ресурса данными запроса.
- **DELETE** удаляет указанный ресурс.
- **CONNECT** устанавливает "туннель" к серверу, определённому по ресурсу.
- **OPTIONS** используется для описания параметров соединения с ресурсом.
- **TRACE** выполняет вызов возвращаемого тестового сообщения с ресурса.
- **PATCH** используется для частичного изменения ресурса.

Чаще всего в обмене сообщениями используются **GET** и **POST**.

**Идемпотентность это** свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.

По умолчанию, идемпотентными являются операции **GET**, **DELETE** и **PUT**. Это значит, что если одинаковый запрос к API с этими методами по ошибке будет направлен несколько раз, ничего страшного не произойдет. 

Для других методов идемпотентности иногда требуется достигать вручную. 

### HTTP заголовки:

HTTP-заголовки сопровождают обмен данными по протоколу HTTP. Они могут содержать описание данных и информацию, необходимую для взаимодействия между клиентом и сервером. Заголовки и их статусы перечислены в [реестре IANA](https://www.iana.org/assignments/message-headers/perm-headers.html), который постоянно обновляется.
**Основные заголовки запросов:**

- Accept - определяет формат ответа, который устроит клиент.
- Accept-enсoding -  информация о кодиовках, которые должны быть в ответе.
- Accept-language - информация о языках, которые могут быть в ответе.
- Cache-control- кэшировать запросы или нет.
- Cookie - дополнительная информация из файлов cookie.
- Referer - сайт, с которого клиент перешел на сайт.
- User-agent - информация о клиенте.
- И т.д.

**Основные заголовки ответов:**

- Accept-ch - подсказывает, какие заголовки клиент должен включать в последующие запросы.
- Cache-control - информация о производимом кэшировании.
- Content-encoding - как именно кодируется информация из тела ответа.
- Content-type - в каком виде передается информация из тела ответа.
- Date - время, когда пришел запрос.
- Expires - время, до которого возвращенные данные будут оставаться валидными.
- Set-cookie - информация, которую нужно записать в cookie.
- Status - статус запроса.

### HTTP тело:

Это любая информация, которую может передать клиент серверу или сервер клиенту. 

Эта информация может содержаться в любом формате, однако необходимо напрямую указывать этот формат, чтобы информацию можно было обработать соответствующим образом. 

### Коды ответов:

Основных типов кодов ответов пять:

- 1хх - информационные:
- 2хх - успех
- 3хх - перенаправление
- 4хх - ошибка клиента
- 5хх - ошибка сервера

Посмотреть список ошибок подробнее можно здесь:

[Коды состояния ответа HTTP - HTTP | MDN](https://developer.mozilla.org/ru/docs/Web/HTTP/Status)

Коды, которые корректно возвращать в той или иной ситуации могут быть дискуссионными. Например, спорные ситуации могут возникать вокруг пустых ответов. Если на запрос клиента нет данных, которые можно было бы вернуть, но при этом запрос составлен корректно, либо если на запрос пользователя был получен пустой массив, но ошибок не возникало, правильнее будет вернуть код 200, а не 400 или 404.

### Коротко про устройство интернета

**Интернет** (куча соединённых проводов), по своей сути, полагается на протокол управления передачей (**TCP** - Transmission Control Protocol) и интернет-протокол (**IP** - Internet Protocol) для обеспечения возможности передачи данных.

Протокол **TCP** отвечает за разбиение данных на пакеты, обеспечение надежной доставки и повторную сборку их в пункте назначения. 

**IP** обрабатывает маршрутизацию этих пакетов по сетям, гарантируя, что они дойдут до предполагаемого получателя (грубо говоря, это адрес конкретной точки и способ их объединения в общую сеть).
Система доменных имен (**DNS** - Domain Name System) служит адресной книгой Интернета, переводя удобочитаемые доменные имена, такие как "example.com " на IP-адреса типа "192.0.2.1". Этот процесс позволяет нам получать доступ к веб-сайтам без необходимости запоминать их конкретные IP-адреса.

Протокол передачи гипертекста (**HTTP** - Hypertext Transfer Protocol) является основополагающим для веб-коммуникации. HTTP позволяет веб-браузерам запрашивать ресурсы с веб-серверов, облегчая загрузку веб-сайтов, изображений, видео и другого контента. Через HTTP клиенты (такие как веб-браузеры) и серверы могут эффективно обмениваться информацией, обеспечивая динамичный веб-интерфейс (грубо говоря это структурированные правила общения клиентов с сервером, когда каждый понимает, что от него хотят).

**Допустим, пользователь хочет посетить веб-сайт `www.example.com`:**

1. Пользователь вводит адрес `www.example.com` в браузере.

2. Браузер отправляет запрос на DNS-сервер, чтобы преобразовать доменное имя `www.example.com` в IP-адрес.

3. DNS-сервер возвращает IP-адрес веб-сервера, обслуживающего веб-сайт `www.example.com`.

4. Браузер отправляет HTTP-запрос на веб-сервер по указанному IP-адресу.

5. Веб-сервер обрабатывает HTTP-запрос и отправляет браузеру HTTP-ответ с содержимым веб-сайта.

6. Браузер отображает содержимое веб-сайта пользователю. В результате пользователь видит на своем экране содержимое веб-сайта `www.example.com`

## Понятие API

**API** *(Application programming interface)* — это контракт, который предоставляет программа и по которому с ней могут взаимодействовать другие программы и клиенты.

Любое API включает в себя:

- Набор операций, которые оно может выполнить.
- Данные, которые поступают на вход.
- Данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

### Критерии качества API:

- Структураня целостность
- Очевидность и прозрачность
- Консистентность
- Читаемость
- Устойчивость к изменениям

### Структура и иерархия:

- Разные сущности должны быть слабо связаны между собой, чтобы в случае изменения одной сущности другие не ломались, а продолжали корректно работать
- Должны иметься высокоуровненые абстракции
- Уровни абстракции должны быть изолированы, взаимодействие должно быть только между соседними слоями
- Необходимо разграничение областей ответственности

### Требования к API:

- **Идемпотентность** (*см. выше*)
- **Атомарность** - если какая-то часть запроса не может быть выполнена или вызывает ошибку, отвергнут должен быть весь запрос целиком.

### Эндпоинты (ручки):

**API endpoint** — это конечная точка в API, к которой можно обратиться для выполнения нужного действия или получения данных. Endpoint представляет собой URL, по которому отправляются запросы для взаимодействия с API.

**Именование ручек:**

- Из записи **METHOD** + **URL** должно быть понятно, что делает операция.

Например:

```html
# метод + сущность + действие
POST /order/cancel
GET /order/status
```

- Если операция модифицирующая, это должно быть очевидно из сигнатуры.

Например:

```html
# Через POST/PUT/PATCH производим какие-то изменения на бекенде
POST /order/cancel
# Через GET получаем что-то, не внося никаких изменений
GET /order/status
# Через DELETE удаляем что-то
DELETE /order/{order_id}
```

- Сущности надо называть на английском и таким образом, чтобы из названий было ясно, что они из себя представляют.
- Нужно использовать определенную семантику в названиях и стараться избегать сокращений, за исключением устоявшихся.
- К булевым сущностям стоит добавлять соответствующие префиксы.

Например:

```html
is_valid # хорошо
valid # плохо

has_discount # хорошо
discount # плохо
```

- Стоит добавлять множественное число к массивам.
- Нужно избегать двойных отрицаний.

**Советы по проектированию:**

- Явно прописывать форматы и типы данных, которые подаются на вход и передаются на выход.
- Можно указывать формат прямо в названии поля.
- Цены не стоит передавать в формате с плавающей запятой: либо использовать формат с фиксированной запятой, либо использовать целые числа / строки.
- Если необходимо использовать идентификаторы, стоит использовать глобальные уникальные (например uuid).
- Если идентификаторы есть у разных сущностей, можно добавить в них пространство имен.

Например:

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%203.png)

**Не стоит использовать автоинкремент!**

### Обработка ошибок

- Для обработки ошибок стоит разделить сообшение, которое будет видеть пользователь, и машиночитаемое сообщение, которое будет использоваться в коде.

Например:

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%204.png)

Если в процессе обработки запроса возникло сразу несколько ошибок:

- Если есть возможность вывести все сразу, лучше это сделать.
- Если такой, возможности нет, то сперва нужно вывести неразрешимыые ошибки.
- Затем нужно показать критические ошибки, затем - менее значимые.
- Нужно действовать так, чтобы решение одних ошибок не вызывало повторного появления уже решенных и не приводило к закицливанию.

### Ограничения доступа

Коды ошибок для ограничения трафика, доступа или перенаправления на капчу лучше предусматривать на раннем этапе проектирования API, чтобы в будущем не вызывать конфликтов.

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%205.png)

### Версионирование API

Выпускать новые версии всей API имеет смысл при необходимости внести обратно несовместимые изменения.

**Обратно несовместимые изменения**

Некоторые изменения, вносимые в API, могут приводить к тому, что клиенты, которые ранее подключались к нему и пользовались его функционалом, могут начать получать ошибки, выполняя привычные операции. 

К таким изменениям относятся, к примеру:

- Добавление новых обязательных параметров, полей или хедеров в запрос.
- Удаление обязательных полей или хедеров из ответа.
- Добавление новых значений в enum.
- Добавление новых кодов ответа.
- Изменение формата или типа полей.
- Изменение метода у эндпоинта.
- И т.д.

Такие изменение стоит вносить только в рамках новой версии API.

В отдельных случаях, допустимо выпускать новые версии только для отдельных эндпоинтов.

## FastAPI

### REST API

**REST API** (Representational State Transfer) ****— это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и какие функции поддерживать. Это позволяет стандартизировать работу программных интерфейсов, сделать их более удобными и производительными.

**REST** - это не протокол, а простой список рекомендаций, которым можно следовать или не следовать, поэтому у него нет собственных методов. Обычно его используют в связке с HTTP. 

**Принципы REST:**

- Клиент-серверная архитектура
- Отсутствие состояния (сервер не хранит информацию о предыдущих запросах клиента)
- Кэширование
- Единообразие интерфейса
- Слоистая архитектура

### Введение в FastAPI

**FastAPI** - это современный веб-фреймворк, который помогает разработчикам быстро и эффективно создавать API.

**Ключевые особенности FastAPI:**

- Поддержка асинхронности
- Автоматическое документирование
- Подсказки типов и проверка данных
- Внедрение зависимостей
- Простой и интуитивно понятный синтаксис

Чтобы начать работать с FastAPI необходимо установить сам **FastAPI** и сервер **ASGI** (или **WSGI**):

```bash
$ pip install fastapi[all]
$ pip install uvicorn[standard]
```

**Простейшее приложение на FastAPI c методом GET** выглядит следующим образом:

```python
# файл называется main.py
from fastapi import FastAPI 

# переменная с приложением называется app
app = FastAPI()

@app.get("/")
async def root():
    return {'message' : 'Hello World!'}
```

Запустить его можно в консоли при помощи **uvicorn**:

```bash
$ uvicorn main:app --reload
```

В результате, на [http://localhost:8000](http://localhost:8000/) откроется такая страница с JSON:

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%206.png)

Чтобы вместо этого **отобразить страницу HTML**, можно использовать следующую команду:

```python
from fastapi import FastAPI 
from fastapi.responses import FileResponse

app = FastAPI()

@app.get("/")
async def root():
    return FileResponse("index.html")
```

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%207.png)

### Структура проекта

Рекомендуемая структура проекта выглядит так:

- Каталог "**app**" (приложение) содержит основной модуль приложения и вложенные пакеты для моделей и маршрутов.
- [**main.py](http://main.py)** — точка входа в наше приложение FastAPI.
- Каталог "**models**" используется для определения моделей Pydantic для обработки проверки данных запросов и ответов.
- Каталог "**routes**" (маршруты) будет содержать маршруты API (конечные точки), которые определяют поведение приложения.

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%208.png)

### Документация

FastAPI предоставляет интерактивную документацию (с возможностью осуществления тестирования API при помощи Swagger UI).

Документацию можете посмотреть по ссылкам [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)  и [http://127.0.0.1:8000/redoc](http://127.0.0.1:8000/redoc) (альтернативная).

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%209.png)

### **Pydantic-модели**

**Pydantic** является Python-библиотекой для выполнения валидации данных.

Вы объявляете «форму» данных как **классы с атрибутами**.

И каждый атрибут имеет **тип**.

Затем вы создаете экземпляр этого класса с некоторыми значениями, и он проверяет значения, преобразует их в соответствующий тип (если все верно) и предоставляет вам объект со всеми данными.

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%2010.png)

![Untitled](Разработка/API%20и%20HTTP/Вложения/API%20и%20HTTP/Untitled%2011.png)

Чтобы **реализовать простейший запрос с методом POST**, нужно выполнить следующий алгоритм:

```python
from fastapi import FastAPI 
# импортируем pydantic BaseModel
from pydantic import BaseModel

app = FastAPI()

# создаем класс, который определяет параметры, 
# которые будут передаваться в тело запроса
class SNums(BaseModel):
    num1: int
    num2: int

# создаем функцию с декоратором post, в которую в качестве параметра
# передается объект созданного класса
@app.post('/calculate')
async def calculate(body: SNums):
    return {"result": body.num1 + body.num2}
```

Делаем запрос, например, из командной строки:

```bash
curl -X POST \
	"http://localhost:8000/calculate" \
	-H "Content-Type: application/json" \
	-d '{"num1": 5, "num2": 3}'

>> {"result": 8}
```

Более сложные модели можно создавать при помощи методов из библиотеки **typing**.

Например, U**nion** используется для объединения типов:

```python
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
```

В данном случае мы говорим, что тип у description может быть либо строкой, либо None, а также говорим, что параметр не обязателен (`= None`) - задаём значение по-умолчанию.

### Параметры пути и запроса

1) **Path-параметры** указывается в маршруте в фигурных скобках {}, а потом в обработчике маршрута:

```python
@app.get("/{some_param}")

async def func_with_path_param(some_param: <type>):
```

```python
@app.get('/character/get/{name}')
async def get_char(name: str):
    with open('data.json','r') as file:
        libr = json.load(file)
        if name in libr:
            return {"answer" : libr[name]}
    return {"answer":"no data"}
```

или прописываем явно:

```python
@app.get("/{some_param}")

async def func_with_path_param(some_param: Annotated[<type>, Path()]):
```

2) **Body-параметры** представлены в виде Pydantic-моделей и указываются в виде параметра обработчика маршрута с типом соответствующего класса модели (о чем рассказывалось ранее):

```python
@app.post("/")

async def func_with_body_param(user: User):
```

или прописываем явно:

```python
@app.post("/")

async def func_with_body_param(user: Annotated[User, Body()]):
```

3) **Query-параметры** представлены просто в виде параметров обработчика маршрута (объявлены не двумя предыдущими способами):

```python
@app.get("/")

async def func_with_body_param(query_param: <type>):
```

или указываем явно:

```python
@app.get("/")

async def func_with_body_param(query_param: Annotated[<type>, Query()]):
```

```python
from fastapi import FastAPI

app = FastAPI()

fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

@app.get("/items/")
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]
```

`Query`-параметры представляют из себя набор пар ключ-значение, которые идут после знака `?` в URL-адресе, разделенные символами `&` .

Например, в этом URL-адресе:

`http://127.0.0.1:8000/items/?skip=0&limit=10`

параметры запроса такие:

- `skip`: со значением `0`
- `limit`: со значением `10`

FastAPI поддерживает обработку загрузки **файлов** как части запроса. Вы можете использовать класс **`File`** из модуля ``fastapi``, чтобы определить конечную точку загрузки файла и получить доступ к загруженным файлам в вашей функции роута.

```python
from typing import Annotated 
from fastapi import FastAPI, File, UploadFile

app = FastAPI()

@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}

@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}
```